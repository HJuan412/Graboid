#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Apr 25 11:03:08 2023

@author: nano

Paired distance calculation for database calibration
"""

#%% libraries
import concurrent.futures
import numpy as np
# Graboid libraries
from classification import classification

#%% functions
def get_ndists(idx, win, win_sites, cost_mat):
    # get all distances between item at position idx and the FOLLOWING elements in win for each level in win_sites (contains n_sites indexes)
    # returns dist_array and index_array
    # dist_array contains the calculated distances. It has a row for each level in win_sites and the number of columns equals the number of elements AFTER idx in win
    # index_array has the indexes of the pair of elements in each column of dist_array. Has two rows, idx goes in the upper one
    
    # pre generate arrays
    dist_array = np.zeros((len(win_sites), win.shape[0] - 1 - idx), dtype=np.float32)
    # construct index_array
    index_array = np.full((2, win.shape[0] - 1 - idx), idx, dtype=np.int16)
    index_array[1] = np.arange(idx + 1, win.shape[0])
    # calculate distances for each level in win_sites
    for nidx, n in enumerate(win_sites):
        # for each level, the distance includes the distance of the previous levels
        prev_dists = dist_array[max(nidx-1, 0)]
        dist_array[nidx] = classification.get_dists(win[[idx]][:,n], win[idx+1:][:,n], cost_mat)[0] + prev_dists
    
    return dist_array, index_array

def get_paired_distances(win, win_sites, cost_mat, idx=''):
    # get all possible paired distances in a single array per level
    # returns the concatenated dist_arrays and idx_arrays generated by get_ndists
    total_dists = np.empty((len(win_sites), 0), dtype=np.float32)
    total_indexes = np.empty((2,0), dtype=np.int16)
    # run get_ndists for every element except the last one, as it has no FOLLOWING elements
    for idx in np.arange(win.shape[0]-1):
        dists, indexes = get_ndists(idx, win, win_sites, cost_mat)
        # concatenate results to the existing matrices
        total_dists = np.concatenate((total_dists, dists), axis=1)
        total_indexes = np.concatenate((total_indexes, indexes), axis=1)
    print(f'Calculated paired distances for window {idx}')
    return total_dists, total_indexes

def get_all_distances(win_list, window_sites, cost_mat, threads=1, win_idxs=None):
    # get paried distances for all windows cnotained in win_list, using for each one their corresponding sites
    # win_idxs is used to signal when calculations are finished for a given window
    if win_idxs is None:
        win_idxs = np.arange(len(win_list))
    with concurrent.futures.ProcessPoolExecutor(max_workers=threads) as executor:
        all_win_dists = [dst for dst in executor.map(get_paired_distances, [win.window for win in win_list], window_sites, [cost_mat]*len(win_list), win_idxs)]
    return all_win_dists