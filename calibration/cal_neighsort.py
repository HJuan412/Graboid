#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Apr 25 11:35:28 2023

@author: nano

Sort neighbours by distances
"""

#%% libraries
import concurrent.futures
import numpy as np

#%% functions
def get_sorted_neighs(sorted_idxs, sorted_dists, lvl=''):
    # separate the neighbours for each individual element in the paired distance matrix
    # sorted_idxs contains the indexes array generated by get_all_distances, ordered by the distances calculated for a given level
    # returns arrays neighs (containing neighbour indexes) and dists (containing neighbour distances to the element)
    neighs = []
    dists = []
    # isolate the neighbours of each element and their respective distances
    for seq in np.arange(sorted_idxs.max() + 1):
        # get all pairs that include the current element
        seq_idxs = sorted_idxs == seq
        combined = seq_idxs[0] | seq_idxs[1] 
        seq_neighs = sorted_idxs[:, combined]
        # extract the ordered distances for the current element's neighbours
        dists.append(sorted_dists[combined])
        # extract the current element's neighbours' indexes
        ordered_neighs = np.full(seq_neighs.shape[1], -1, dtype=np.int16)
        ordered_neighs[seq_neighs[0] != seq] = seq_neighs[0][seq_neighs[0] != seq]
        ordered_neighs[seq_neighs[1] != seq] = seq_neighs[1][seq_neighs[1] != seq]
        neighs.append(ordered_neighs)
    print(f'Sorted level {lvl}')
    return np.array(neighs), np.array(dists)

# sort the generated distance arrays
def sort_neighbours(win_list, all_win_dists, threads=1, win_idxs=None):
    # win_dists is a list of #windows elements, each contains 2 np arrays:
        # the first one has the paired distances for each n level (shape (n levels, #seq pairs))
        # the second one is a (2, #seq pairs) array containing the indexes of each sequence pair
    # win_idxs is used to signal when calculations are finished for a given window
    if win_idxs is None:
        win_idxs = np.arange(len(win_list))
    
    with concurrent.futures.ProcessPoolExecutor(max_workers=threads) as executor:
        # for each window, we are getting the ascending ORDER for the distance calculated at each level
        sorted_dists = [dists for dists in executor.map(np.argsort, [win_d[0] for win_d in all_win_dists], [1]*len(win_list))] # win_d[0] contains the distances array, win_d[1] contains the paired indexes (seqA, seqB) (used later)
    
    sorted_win_neighbours = []
    # sorted_win_neighbours is structured as:
        # window:
            # n level:
                # sorted neighbour idxs
                # sorted neighbour dists
                # both these arrays have shape (#seqs, #seqs - 1), as each row has #seqs - 1 neighbours                    
    for w_idx, win_dists, sorted_win_dists in zip(win_idxs, all_win_dists, sorted_dists):
        sorted_idxs = [win_dists[1][:, lvl] for lvl in sorted_win_dists] # list containing the paired indexes sorted for each n level
        sorted_distances = [dsts[lvl] for dsts, lvl in zip(win_dists[0], sorted_win_dists)]
        print(f'Sorting neighbours for window {w_idx}')
        with concurrent.futures.ProcessPoolExecutor(max_workers=threads) as executor:
            sorted_win_neighbours.append([ordered for ordered in executor.map(get_sorted_neighs, sorted_idxs, sorted_distances, np.arange(len(sorted_idxs)))])
    
    return sorted_win_neighbours