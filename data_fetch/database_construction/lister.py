#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Sep 20 10:33:36 2021

@author: hernan
This script generates accession list tables from the summary files generated by db_survey
"""

#%% libraries
from glob import glob
import os
import pandas as pd

#%% functions
# file managing
def build_summ_tab(summ_dir):
    # generate information table for the summary files
    # get taxon, marker, database and path information for each file
    summ_files = glob(f'{summ_dir}/*summ')
    summ_tab = pd.DataFrame(columns = ['Taxon', 'Marker', 'Database', 'File'])
    
    for file in summ_files:
        split_file = file.split('/')[-1].split('.summ')[0].split('_')
        row = {'Taxon':split_file[0],
               'Marker':split_file[1],
               'Database':split_file[2],
               'File':file}
        summ_tab = summ_tab.append(row, ignore_index=True)
    return summ_tab

# data loading
def read_BOLD_summ(summ_file):
    # extract a list of accessions from a BOLD summary
    bold_tab = pd.read_csv(summ_file, sep = '\t', encoding = 'latin-1', dtype = str) # latin-1 to parse BOLD files
    accs = bold_tab['sampleid'].tolist()
    return accs

def read_NCBI_summ(summ_file):
    # extract a list of accessions from an NCBI or ENA summary
    ncbi_tab = pd.read_csv(summ_file, sep = '\t')
    accs = ncbi_tab.iloc[:,0].tolist()
    return accs

#%% classes
class SummProcessor():
    def __init__(self, taxon, marker, database, in_file, out_dir, old_dir = None):
        self.taxon = taxon
        self.marker = marker
        self.database = database
        self.out_dir = out_dir
        self.get_old_subtab(taxon, marker, database, old_dir)
        self.set_readfunc(database)
        self.accs = self.readfunc(in_file)
    
    def set_readfunc(self, dbase):
        # database determines how the file is read
        if dbase == 'BOLD':
            self.readfunc = read_BOLD_summ
        elif dbase == 'NCBI':
            self.readfunc = read_NCBI_summ
    
    def get_old_subtab(self, tax, mark, dbase, old_dir):
        # locate previous acc list for this tax - mark - dbase trio
        old_file_path = f'{old_dir}/{tax}_{mark}_{dbase}.acc'
        self.old_subtab = None
        if old_dir is not None:
            if os.path.isfile(old_file_path):
                self.old_subtab = pd.read_csv(old_file_path)
                
    def get_shortaccs_ver(self):
        # split the accession code from the version number, return both
        splitaccs = [acc.split('.') for acc in self.accs]
        vers = [acc[-1] for acc in splitaccs]
        shortaccs = [acc.split(f'.{ver}')[0] for acc, ver in zip(self.accs, vers)]
        return shortaccs, vers
    
    def build_acc_subtab(self):
        shortaccs, vers = self.get_shortaccs_ver()
        acc_subtab = pd.DataFrame({'Accession': self.accs, 'Version':vers}, index = shortaccs)
        acc_subtab['Entry'] = 1 # this code tells the next step how to handle this entry

        self.acc_subtab = acc_subtab
        self.out_tab = acc_subtab.copy()
    
    def compare_tab(self):
        # compare acc_subtab to old_subtab (if present)
        if self.old_subtab is not None:
            long_accs = self.acc_subtab['Accession']
            self_vers = self.acc_subtab['Version']
            old_vers = self.old_subtab['Version']
            mixed_df = pd.DataFrame[{'Accession':long_accs, 'Version':self_vers, 'old':old_vers}].fillna(0)
            mixed_df['Entry'] = 0 # do nothing
            # new entries
            mixed_df.at[mixed_df['old'] == 0, 'Entry'] = 1 # new entry
            mixed_df.at[(mixed_df['old'] > 0) & (mixed_df['old'] != mixed_df['Version']), 'Entry'] = 2 # new version
            mixed_df.at[mixed_df['Version'] == 0] = -1 # missing entry
            self.out_tab = mixed_df[['Accession', 'Version', 'Entry']]
    
    def clip_redundant(self, acclist):
        # clip records present in another list
        self.out_tab = self.out_tab.at[self.out_tab.index.isin(acclist), 'Entry'] = 0
        
    def store_tab(self):
        filename = f'{self.out_dir}/{self.taxon}_{self.marker}_{self.database}.acc'
        self.out_tab.to_csv(filename)
    
    def process(self, acclist):
        self.build_acc_subtab()
        self.compare_tab()
        # self.clip_redundant(acclist)
        self.store_tab()
        return set(self.out_tab.loc[self.out_tab['Entry'] == 1].index)
    
class Lister():
    def __init__(self, in_dir, out_dir, warn_dir, old_dir = None):
        self.in_dir = in_dir
        self.out_dir = out_dir
        self.warn_dir = warn_dir
        self.set_summ_tab()
        self.old_dir = old_dir
        self.accs = set()
    
    def set_summ_tab(self):
        # get data and preprocess
        self.summ_tab = build_summ_tab(self.in_dir)

    def check_summaries(self):
        # make sure summ_tab is not empty
        if len(self.summ_tab) == 0:
            with open(f'{self.warn_dir}/lister.warn', 'w') as warn_handle:
                warn_handle.write('No summary files found in directory {self.in_dir}')
            return False
        return True

    def build_lists(self):
        if self.check_summaries:
            for idx, row in self.summ_tab.iterrows():
                tax = row['Taxon']
                mark = row['Marker']
                dbase = row['Database']
                file = row['File']
                summproc = SummProcessor(tax, mark, dbase, file, self.out_dir, self.old_dir)
                new_accs = summproc.process(self.accs)
                self.accs = self.accs.union(new_accs)
